<!DOCTYPE html>

<html>

<head>
    <title>Example 02.08 - Cameras</title>
    <script type="text/javascript" src="./libs/three.js"></script>

    <script type="text/javascript" src="./libs/stats.js"></script>
    <script type="text/javascript" src="./libs/dat.gui.js"></script>
    <script type="text/javascript" src="./libs/tween.min.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">
    var data = [
        {x:0,y:0.1,z:80,rt:-0.8},
        {x:80,y:0.2,z:0,rt:-0.2},
        {x:80,y:0.2,z:-50,rt:-0.6}
    ]
    // once everything is loaded, we run our Three.js stuff.
    function init() {

        var stats = initStats();

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.x = -100;
        camera.position.y = 90;
        camera.position.z = 0;

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();

        renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
        renderer.setSize(window.innerWidth, window.innerHeight);

        // create the ground plane
        var planeGeometry = new THREE.PlaneGeometry(180, 180);
        var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);


        // rotate and position the plane
        plane.rotation.x = -0.5 * Math.PI;
        plane.position.x = 0;
        plane.position.y = 0;
        plane.position.z = 0;

        // add the plane to the scene
        scene.add(plane);

        

        var lookAtGeom = new THREE.SphereGeometry(2);
        var lookAtMesh = new THREE.Mesh(lookAtGeom, new THREE.MeshLambertMaterial({color: 0xff0000}));
        scene.add(lookAtMesh);


        var directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(-20, 40, 60);
        scene.add(directionalLight);


        // add subtle ambient lighting
        var ambientLight = new THREE.AmbientLight(0x292929);
        scene.add(ambientLight);

        // add the output of the renderer to the html element
        document.getElementById("WebGL-output").appendChild(renderer.domElement);

        // call the render function
        var step = 0;

        // make sure that for the first time, the
        // camera is looking at the scene
        //   camera.lookAt(scene.position);
        render();


        var step = 0;
        function cameraAction(){
            step += 0.02;
            if (camera instanceof THREE.Camera) {
                var x = 10 + ( 100 * (Math.sin(step)));
                camera.lookAt(new THREE.Vector3(x, 10, 0));
                lookAtMesh.position.copy(new THREE.Vector3(x, 10, 0));
            }
        }
        function createPanel(){
            function getPanel(object){
                console.log(object)
                var planeGeometry = new THREE.PlaneGeometry(10, 20);
                var planeMaterial = new THREE.MeshLambertMaterial({color: 'red'});
                var plane = new THREE.Mesh(planeGeometry, planeMaterial);


                // rotate and position the plane
                plane.rotation.x = -0.5 * Math.PI;
                plane.position.x = 0;
                plane.position.y = 0;
                plane.position.z = 0;

                // add the plane to the scene
                scene.add(plane);
                var sp = {
                    x:0,
                    y:0,
                    z:0
                }
                var tween = new TWEEN.Tween(sp).to({x:object.x, y:object.y, z:object.z, rz:object.rt * Math.PI}, 1000).onUpdate(function(){
                    plane.position.x = this.x;
                    plane.position.y = this.y;
                    plane.position.z = this.z;
                    plane.rotation.z = this.rz;
                })
                return tween
            }
            var temp;
            for (let d in data){
                if(d==0){
                   var tweenObject = getPanel(data[d]);
                   temp = tweenObject;
                   tweenObject.start();
                }else{
                   var tweenObject1 = getPanel(data[d]);
                   temp.chain(tweenObject1)
                   temp = tweenObject1
                }
            }
            // tween2.chain(tween);





            // var planeGeometry = new THREE.PlaneGeometry(10, 20);
            // var planeMaterial = new THREE.MeshLambertMaterial({color: 'red'});
            // var plane = new THREE.Mesh(planeGeometry, planeMaterial);


            // // rotate and position the plane
            // plane.rotation.x = -0.5 * Math.PI;
            // plane.position.x = 0;
            // plane.position.y = 0;
            // plane.position.z = 0;

            // // add the plane to the scene
            // scene.add(plane);
           
            // var plane2 = new THREE.Mesh(planeGeometry, planeMaterial);
            // // rotate and position the plane
            // plane2.rotation.x = -0.5 * Math.PI;
            // plane2.position.x = 0;
            // plane2.position.y = 0;
            // plane2.position.z = 0;

            // // add the plane to the scene
            // scene.add(plane2);
            // var sp = {
            //     x:0,
            //     y:0,
            //     z:0
            // }
            // var sp1 = {
            //     x:0,
            //     y:0,
            //     z:0
            // }
            // var tween = new TWEEN.Tween(sp).to({x:0, y:0.2, z:80, rz:-0.8 * Math.PI}, 1000).onUpdate(function(){
            //     plane.position.x = this.x;
            //     plane.position.y = this.y;
            //     plane.position.z = this.z;
            //     plane.rotation.z = this.rz;
            // })
            // var tween2 = new TWEEN.Tween(sp1).to({x:80, y:0.2, z:0, rz:-0.2 * Math.PI}, 1000).onUpdate(function(){
            //     plane2.position.x = this.x;
            //     plane2.position.y = this.y;
            //     plane2.position.z = this.z;
            //     plane2.rotation.z = this.rz;
            // }).start();
            // tween2.chain(tween);
        }
        createPanel();
        function render() {

            stats.update();
            TWEEN.update();
            // render using requestAnimationFrame
            // cameraAction();
            camera.lookAt(new THREE.Vector3(0, 0, 0));
        // .position.x = 20+( 10*(Math.cos(step)));
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }

        function initStats() {

            var stats = new Stats();

            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.getElementById("Stats-output").appendChild(stats.domElement);

            return stats;
        }
    }
    window.onload = init


</script>
</body>
</html>